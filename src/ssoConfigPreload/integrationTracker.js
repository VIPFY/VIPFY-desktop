console.log("Testing");
let ipcRenderer = require("electron").ipcRenderer;
var iframeList = [];
let stopped = false;
let cookiefound = false;
let recaptchaConfirmOnce = false;
let checkRecaptcha = false;
let bot = false;
let webview;

var listeners = [];

const asktypes = ["input", "textbox"];

(function () {
  Element.prototype._addEventListener = Element.prototype.addEventListener;
  Element.prototype.addEventListener = function (a, b, c) {
    if (c == undefined) c = false;
    this._addEventListener(a, b, c);
    if (!this.eventListenerList) this.eventListenerList = {};
    if (!this.eventListenerList[a]) this.eventListenerList[a] = [];
    //this.removeEventListener(a,b,c); // TODO - handle duplicates..
    this.eventListenerList[a].push({ listener: b, useCapture: c });
  };

  Element.prototype.getEventListeners = function (a) {
    if (!this.eventListenerList) this.eventListenerList = {};
    if (a == undefined) return this.eventListenerList;
    return this.eventListenerList[a];
  };
  Element.prototype.clearEventListeners = function (a) {
    if (!this.eventListenerList) this.eventListenerList = {};
    if (a == undefined) {
      for (var x in this.getEventListeners()) this.clearEventListeners(x);
      return;
    }
    var el = this.getEventListeners(a);
    if (el == undefined) return;
    for (var i = el.length - 1; i >= 0; --i) {
      var ev = el[i];
      this.removeEventListener(a, ev.listener, ev.useCapture);
    }
  };

  Element.prototype._removeEventListener = Element.prototype.removeEventListener;
  Element.prototype.removeEventListener = function (a, b, c) {
    if (c == undefined) c = false;
    this._removeEventListener(a, b, c);
    if (!this.eventListenerList) this.eventListenerList = {};
    if (!this.eventListenerList[a]) this.eventListenerList[a] = [];

    // Find the event in the list
    for (var i = 0; i < this.eventListenerList[a].length; i++) {
      if (
        (this.eventListenerList[a][i].listener == b, this.eventListenerList[a][i].useCapture == c)
      ) {
        // Hmm..
        this.eventListenerList[a].splice(i, 1);
        break;
      }
    }
    if (this.eventListenerList[a].length == 0) delete this.eventListenerList[a];
  };
})();

Object.defineProperty(String.prototype, "includesAny", {
  value: function (searches) {
    for (const search of searches) {
      if (this.indexOf(search) !== -1) {
        return true;
      }
    }
    return false;
  }
});

Object.defineProperty(String.prototype, "includesAnyRegExp", {
  value: function (searches) {
    for (const search of searches) {
      if (search.test(this)) {
        return true;
      }
    }
    return false;
  }
});

const skipArgs = ["placeholder", "alt", "title", "aria-label"]; // don't use attributes likely to get translated
const hash = require("object-hash");
function createObjFromDom(elem) {
  if (elem == null) return null;
  //console.log(elem);
  if (elem.nodeType !== 1) {
    // ELEMENT_NODE
    return null;
  }
  const o = { tag: elem.tagName };
  if (elem.hasAttributes) {
    o.attr = {};
    for (const attr of elem.attributes) {
      if (skipArgs.includes(attr.name.toLowerCase())) {
        continue;
      }
      if (attr.name.includesAny([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])) {
        // attributes with numbers are likely to be autogenerated
        continue;
      }
      if (attr.value == "") {
        // empty attributes are often not a good selector choice
        continue;
      }
      o.attr[attr.name] = attr.value;
    }
  }
  o.empty = !elem.hasChildNodes();
  o.hash = hash(o);
  return o;
}
var i = 0;
ipcRenderer.on("execute", (e, args1) => onExecute(args1, true));

async function onExecute(args1, booler) {
  await execute(args1, booler);
  //reset everything
  await ipcRenderer.sendToHost("readyForNextStep");
  listeners = [];
  iframeList = [];
  stopped = false;
  cookiefound = false;
  recaptchaConfirmOnce = false;
  checkRecaptcha = false;
  bot = false;
}

ipcRenderer.on("delockItem", async (e, args1) => {
  const element = document.querySelector(args1);
  if (element == null) {
    return;
  }
  element.disabled = false;
  element.clearEventListeners(); //entferne das perventDefault
  const listeners1 =
    listeners[
    listeners.findIndex(elemente => {
      return elemente[0] == element;
    })
    ][1];
  Object.keys(listeners1).forEach(key => {
    listeners1[key].forEach(i => element.addEventListener(key, i));
  });
  listeners.splice(
    //entferne alte Objekte wieder aus der Liste
    listeners.findIndex(elemente => {
      return elemente[0] == element;
    }),
    1
  );
  console.log("Events Regiven");
});

ipcRenderer.on("givePosition", async (e, args1, args2, args3) => {
  const ding = document.querySelector(args1);
  if (ding == null) {
    return;
  }
  const rect = ding.getBoundingClientRect();
  ipcRenderer.sendToHost(
    "givePosition",
    ding.clientWidth,
    ding.clientHeight,
    rect.x,
    rect.y,
    args2,
    args3
  );
});

function giveIframeEvents(iframe, list, events) {
  console.log("iframe", iframe, list, events);
  if (list) {
    iframeList.push(iframe);
  }
  if (events) {
    console.log("IDocument", iframe.contentWindow.document);
    iframe.contentWindow.document.addEventListener("click", e => findTarget(e, iframe), true);
    iframe.contentWindow.document.addEventListener("keyup", e => findTarget(e, iframe), true);
    iframe.contentWindow.document.addEventListener("input", e => findTarget(e, iframe), true);
    iframe.contentWindow.document.addEventListener("paste", e => findTarget(e, iframe), true);
    console.log("LOAD FIRST", iframe);
    iframe.addEventListener("load", e => {
      console.log("LOAD", e, iframe);
      iframe.contentWindow.document.addEventListener("keyup", e => findTarget(e, iframe), true);
      iframe.contentWindow.document.addEventListener("input", e => findTarget(e, iframe), true);
      iframe.contentWindow.document.addEventListener("click", e => findTarget(e, iframe), true);
      iframe.contentWindow.document.addEventListener("paste", e => findTarget(e, iframe), true);
    });
    /* iframe.contentWindow.document.addEventListener("DOMSubtreeModified", e => {
      console.log(e.target, e.target.contentWindow.document);
    });*/
  }
  var observer = new MutationObserver(callback2);
  observer.observe(iframe, config);
  /*iframe.contentWindow.document.addEventListener("DOMSubtreeModified", (e) => {
   if (e.target.tagName=="IFRAME"){
        console.log("IFRAME ALL", e);
        e.target.contentWindow.document.addEventListener("keyup", findTarget,true);
        e.target.contentWindow.document.addEventListener("input", findTarget,true);
        e.target.contentWindow.document.addEventListener("click", findTarget,true);
        e.target.contentWindow.document.addEventListener("paste", findTarget,true);
        findAllIframes(e.target.contentWindow.document);
    }
  })
    */
}

function findAllIframes(doc) {
  //console.log("findAllIframes called");
  let iframes = doc.querySelectorAll("iframe");
  iframes.forEach(iframe => findAllIframes(iframe.contentWindow.document));
  let machKaputt = [];
  for (let i = 0; i < iframes.length; i++) {
    const iframe = iframes[i];
    if (iframeList.indexOf(iframe) === -1) {
      machKaputt.push(iframes[i]);
    }
  }
  iframes = machKaputt;
  //console.log("New iframes", iframes)
  iframes.forEach(iframe => giveIframeEvents(iframe, true, true));
}

//console.log(webview[0]);

var config = { attributes: true, childList: true, subtree: true };

var callback1 = function (mutationsList, observer) {
  //console.log(iframeList);
  //var newChilds = [];
  for (var mutation of mutationsList) {
    if (mutation.type == "childList") {
      mutation.addedNodes.forEach(node => {
        //console.log("Node added", node.tagName);
        //if(node.tagName == "IFRAME") {
        //giveIframeEvents(node);
        findAllIframes(document);
        //}
        //newChilds.push(node);
      });
      mutation.removedNodes.forEach(node => {
        //console.log("Node removed", node.tagName);
        if (node.tagName == "IFRAME") {
          var index = iframeList.indexOf(node);
          if (index > -1) {
            iframeList.splice(index, 1);
          }
        }
      });
      /*             console.log('A child node has been added or removed.');
       */
    }
    /* else if (mutation.type == 'attributes') {
            console.log('The ' + mutation.attributeName + ' attribute was modified.');
        } */
  }
  //return newChilds;
};

var callback2 = function (mutationsList, observer) {
  //console.log("Callback2 called");
  for (var mutation of mutationsList) {
    if (mutation.type == "childList") {
      mutation.addedNodes.forEach(node => {
        //console.log("Node added", node.tagName);
        if (node.tagName == "IFRAME") {
          giveIframeEvents(node, false, true);
          findAllIframes(observer.iframe);
        }
      });
      mutation.removedNodes.forEach(node => {
        //console.log("Node removed", node.tagName);
        if (node.tagName == "IFRAME") {
          var index = iframeList.indexOf(node);
          if (index > -1) {
            iframeList.splice(index, 1);
          }
        }
      });
    }
  }
};

//webview.addEventListener("loadend", () => {console.log("Yeaaa")});
/* window.addEventListener("DOMSubtreeModified", (e) => {
    if (e.target.tagName=="IFRAME"){
        console.log("IFRAME", e);
        e.target.contentWindow.document.addEventListener("keyup", findTarget,true);
        e.target.contentWindow.document.addEventListener("input", findTarget,true);
        e.target.contentWindow.document.addEventListener("click", findTarget,true);
        e.target.contentWindow.document.addEventListener("paste", findTarget,true);
        findAllIframes(e.target.contentWindow.document);

        e.target.contentWindow.addEventListener("load", () => {
            e.target.contentWindow.document.addEventListener("keyup", findTarget,true);
            e.target.contentWindow.document.addEventListener("input", findTarget,true);
            e.target.contentWindow.document.addEventListener("click", findTarget,true);
            e.target.contentWindow.document.addEventListener("paste", findTarget,true);
            findAllIframes(e.target.contentWindow.document);
        });
    }
    else if (e.target.id) {
        console.log("EVENT", e)
    }
}) */



/// **
window.addEventListener("DOMContentLoaded", () => {
  ipcRenderer.sendToHost("loaded");
  document.addEventListener("click", findTarget, true);
  document.addEventListener("keyup", findTarget, true);
  document.addEventListener("input", findTarget, true);
  document.addEventListener("paste", findTarget, true);
  findAllIframes(document);
});



// window.addEventListener("load", () => {
//   ipcRenderer.sendToHost("loaded");
//   //webview = document.getElementById("LoginFinder");
//   document.addEventListener("click", findTarget, true);
//   document.addEventListener("keyup", findTarget, true);
//   document.addEventListener("input", findTarget, true);
//   document.addEventListener("paste", findTarget, true);
//   findAllIframes(document);
// });


//document.addEventListener("click", findTarget);
var observer = new MutationObserver(callback1);
observer.observe(document, config);

const attributesSelector = [
  "name",
  "ng-model",
  "data-ng-model",
  "data-callback",
  "data-name",
  "data-testid",
  "data-event-click-target",
  "data-ng-click"
];

function findTarget(event, iframe) {
  ipcRenderer.sendToHost("aktualisiereDivList");
  if (bot) {
    return;
  }
  console.log("findTarget", event, event.target, iframe);
  /* if(event.type == "click") {
        console.log("Event", event)
    } */
  //console.log("Event", event.target)
  const element1 = event.target.cloneNode("true");
  //console.log("CLONE", element1)
  var rect = event.target.getBoundingClientRect();
  const style = window.getComputedStyle(event.target);
  console.log("RECT/STYLE", rect, style);

  var obj = createObjFromDom(element1);
  if (iframe) {
    console.log(createObjFromDom(iframe));
  }

  //const button = event.target;
  const wereans = onClick(event);
  if (wereans[0]) {
    const button = wereans[1];
    const listenersers = button.getEventListeners();
    //ipcRenderer.sendToHost("sendMessage", button, listeners);
    listeners.push([event.target, listenersers]); //
    button.clearEventListeners();
    button.addEventListener("click", e => {
      e.preventDefault();
      return false;
    });
    console.log("Events Cleared");
  }
  console.log("Parents", els);

  if (wereans[0]) {
    var button = wereans[1];
  } else {
    var button = event.target;
  }

  var els = [];
  var a = button;
  while (a) {
    els.unshift(a);
    a = a.parentNode;
  }
  if (iframe) {
    a = iframe;
    while (a) {
      els.unshift(a);
      a = a.parentNode;
    }
  }

  var doc = iframe ? iframe.contentWindow.document : document;
  var iselector;
  var selector = "[id='" + obj.attr.id + "']";
  var t = Array.from(doc.querySelectorAll(selector));

  if (t.length != 1) {
    //Either no id or multiple with same
    selector = element1.tagName;
    console.log(obj.attr);
    for (key of Object.keys(obj.attr)) {
      if (["name", "type", "id", "for", "data-qa"].includes(key)) {
        selector += "[" + key + "='" + obj.attr[key] + "']";
      }
    }
    console.log("Selector", selector);
    t = Array.from(doc.querySelectorAll(selector));

    if (t.length != 1) {
      console.log("Need Parents", els);
      var parent = els.pop();
      var pobj;
      var pt;
      var pselector;
      while (parent) {
        pobj = createObjFromDom(parent);
        pt = Array.from(doc.querySelectorAll("#" + pobj.attr.id));
        if (pt.length == 1) {
          selector = "#" + pobj.attr.id + " > " + selector;
          break;
        }
        pselector = parent.tagName;
        for (key of Object.keys(pobj.attr)) {
          if (["name", "type", "id", "for", "data-qa"].includes(key)) {
            pselector += "[" + key + "='" + pobj.attr[key] + "']";
          }
        }
        pt = Array.from(doc.querySelectorAll(pselector));
        selector = pselector + " > " + selector;
        if (pt.length == 1) {
          break;
        }
        parent = els.pop();
      }
    }
  }

  if (iframe) {
    console.log("IFRAME ADD");
    var iobj = createObjFromDom(iframe);
    var ia = iframe;
    var iels = [];
    iselector = "#" + iobj.attr.id;
    while (ia) {
      iels.unshift(ia);
      ia = ia.parentNode;
    }
    var i = Array.from(document.querySelectorAll(iselector));

    if (i.length != 1) {
      //Either no id or multiple with same
      iselector = iframe.tagName;
      console.log(iobj.attr);
      for (key of Object.keys(iobj.attr)) {
        if (["name", "type", "id", "for"].includes(key)) {
          iselector += "[" + key + "='" + iobj.attr[key] + "']";
        }
      }
      console.log("ISelector", iselector);
      i = Array.from(document.querySelectorAll(iselector));

      if (i.length != 1) {
        console.log("Need Parents");
        var iparent = iels.pop();
        var ipobj;
        var ipt;
        var ipselector;
        while (iparent) {
          ipobj = createObjFromDom(iparent);
          ipt = Array.from(document.querySelectorAll("#" + ipobj.attr.id));
          if (ipt.length == 1) {
            iselector = "#" + ipobj.attr.id + " > " + iselector;
            break;
          }
          ipselector = iparent.tagName;
          for (key of Object.keys(ipobj.attr)) {
            if (["name", "type", "id", "for"].includes(key)) {
              ipselector += "[" + key + "='" + ipobj.attr[key] + "']";
            }
          }
          ipt = Array.from(document.querySelectorAll(ipselector));

          if (ipt.length == 1) {
            iselector = ipselector + " > " + iselector;
            break;
          }
          iparent = iels.pop();
        }
      }
    }
  }

  ipcRenderer.sendToHost(
    "sendEvent",
    button.tagName,
    button.type,
    button.value,
    createObjFromDom(element1),
    "ID-Elements " + Array.from(document.querySelectorAll(iselector)).length,
    //document.querySelectorAll("INPUT"),
    event.type,
    selector,
    { x: rect.x, y: rect.y },
    iselector
  ); /* ipcRenderer.sendToHost(
    "sendMessage",
    event.target.tagName,
    event.target.type,
    event.type,
    asktypes.includes(event.target.tagName.toLowerCase()),
    event.type == "click"
  ); */ //clientLeft clientTop

  /* ipcRenderer.sendToHost(
    "sendClick",
    [event.target.clientWidth, event.target.clientHeight, event.offsetX, event.offsetY],
    [
      [event.screenX - event.offsetX, event.screenY - event.offsetY],
      event.target.clientWidth,
      event.target.clientHeight,
      event.target.clientLeft,
      event.target.clientTop
    ]
  );  */ if (
    asktypes.includes(event.target.tagName.toLowerCase()) &&
    event.type == "click" &&
    wereans[0]
  ) {
    ipcRenderer.sendToHost(
      "gotClicked",
      wereans[1].clientWidth,
      wereans[1].clientHeight,
      rect.x,
      rect.y
    );
  } else {
    ipcRenderer.sendToHost(
      "gotClicked",
      event.target.clientWidth,
      event.target.clientHeight,
      rect.x,
      rect.y
    );
  }
  event.target.disabled = true;
}

function elemIsButton(t) {
  if (!t) {
    console.log("Not t");
    return false;
  }
  if (t.tagName == "svg") {
    console.log("CHECK TAGNAME IS SVG");
    return false;
  }
  if (t.tagName == "BUTTON" || t.tagName == "INPUT" || t.tagName == "A" || t.tagName == "LABEL") {
    console.log("has special Tag");
    return true;
  }

  if (
    hasEventHandler(t, "click") ||
    hasEventHandler(t, "mousedown") ||
    hasEventHandler(t, "dragstart") ||
    hasEventHandler(t, "onClick")
  ) {
    console.log("has Eventhandler");
    return true;
  }
  console.log("No Button oder sowas");
  return false;
}

function onClick(e) {
  let t = e.target;
  let isButton = true;
  while (t && !elemIsButton(t) && t.parentElement != null) {
    t = t.parentElement;
  }
  if (!t || t.parentElement == null) {
    t = e.target;
    isButton = false;
  }
  console.log("CHECK TAGNAME", isButton, t);
  return [isButton, t];
}

function hasEventHandler(t, e) {
  console.log("E", t);
  return (
    t["on" + e] ||
    t.getAttribute("on" + e) ||
    (t.getEventListeners(e) && t.getEventListeners(e).length > 0)
  );
}

async function onIpcMessage(e) {
  findTarget(event);
  /* ipcRenderer.sendToHost("sendEvent", event.target.tagName, event.target.type, 
                                        event.target.value, createObjFromDom(element1), document.querySelectorAll("INPUT"), event.type, event.which, 
                                        [event.target.clientHeight, event.target.clientWidth, event.offsetX, event.offsetY]); */
}

function findCookieButton() {
  var t = Array.from(
    document.querySelectorAll(
      "[class~=cc-compliance] > [class~=cc-dismiss], [class~='consent'] > a[class~='call'], [ba-click='{{allow()}}']"
    )
  )
    .filter(e => !isHidden(e))
    .filter(e => !e.disabled);
  if (t.length == 0) {
    var trustArc = document.querySelector("[src*='https://consent-pref.trustarc.com/']");
    if (trustArc) {
      t = Array.from(
        trustArc.contentWindow.document.querySelectorAll("[class~=call], [role='button']")
      );
    }
  }
  if (t.length == 0) {
    t = Array.from(
      document.querySelectorAll(
        "button, input[type='checkbox'], input[type='button'], [role='button'], [class~='btn'], [class~='cc-btn'], [class~='button'], [class~='btn-small']"
      )
    )
      .filter(
        filterDom(
          ["dismiss", "cookie", "consent"],
          ["oauth", "google", "facebook", "linkedin", "forgot", "newsletter"]
        )
      )
      .filter(e => !isHidden(e))
      .filter(e => !e.disabled);
  }
  console.log("Cookies", t);
  return t[0];
}

/* function findRecaptcha() {
  let t = document.querySelector('iframe[src*="/recaptcha/"]');
  console.log("button", t);
  if (t == null) {
    return false;
  }
  return t;
} */

async function start() {
  console.log("TEST");
  await sleep(300);
  totaltime = 0;
  //stopped = true;
  while (!stopped && !checkRecaptcha && totaltime < 5000) {
    if (!cookiefound) {
      let cookiebutton = findCookieButton();
      console.log("FIND", cookiebutton);
      if (cookiebutton) {
        await sleep(300);
        await clickButton(cookiebutton);
        ipcRenderer.sendToHost("reset");
        await new Promise(resolve =>
          ipcRenderer.once("done", async (e, args) => {
            if (stopped) return;
            resolve();
          })
        );
        cookiefound = true;
      }

      let recaptcha = findRecaptcha();
      console.log("recaptcha", recaptcha);

      if (recaptcha) {
        await recaptchaClick(recaptcha);

        checkRecaptcha = true;

        if (!recaptchaConfirmOnce) {
          setInterval(verifyRecaptcha, 200);
        }
      } else {
        // ipcRenderer.sendToHost("recaptchaSuccess");
      }
    }
    console.log("TEST2");
    await sleep(100);
    totaltime += 100;
  }
  console.log("TEST NACH");

  /*await execute([
    { operation: "waitandfill", args: { selector: "#customerUrl", fillkey: "domain" } },
    { operation: "click", args: { selector: "#support-login" } },
    { operation: "waitandfill", args: { selector: "#user_email", fillkey: "username" } },
    { operation: "waitandfill", args: { selector: "#user_password", fillkey: "password" } },
    { operation: "click", args: { selector: "input[type='submit'][name='commit']" } }
  ]);*/
}

function clickButton(targetNode) {
  var rect = getMidPoint(targetNode, 0.5, 0.5);

  //if (stopped) throw new Error("abort");
  const p = new Promise(resolve =>
    ipcRenderer.once("clicked", async (e, key) => {
      //if (stopped) return;
      resolve();
    })
  );
  ipcRenderer.sendToHost("click", rect.x, rect.y);
  return p;
}

function getMidPoint(e, px = 0.2, py = 0.5) {
  var rect = e.getBoundingClientRect();
  const style = window.getComputedStyle(e);
  console.log("STYLES", rect, style);
  return {
    x:
      rect.x +
      parseInt(style.paddingLeft) +
      (rect.width - parseInt(style.paddingLeft) - parseInt(style.paddingRight)) * px,
    y:
      rect.y +
      parseInt(style.paddingTop) +
      (rect.height - parseInt(style.paddingTop) - parseInt(style.paddingBottom)) * py
  }; // bias to the left
}

const sleep = async ms => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

const attributes = [
  "name",
  "id",
  "aria-label",
  "aria-roledescription",
  "placeholder",
  "ng-model",
  "data-ng-model",
  "data-callback",
  "data-name",
  "class",
  "value",
  "alt",
  "data-testid",
  "href",
  "data-event-click-target",
  "data-ng-click"
];

function filterDom(includesAny, excludesAll) {
  includesAny = includesAny.map(i => new RegExp(i));
  excludesAll = excludesAll.map(i => new RegExp(i));
  return function (element) {
    if (!element.hasAttributes()) {
      return false;
    }
    if (element.scrollHeight == 0 || element.scrollWidth == 0) {
      return false; //don't select elements that aren't visible
    }
    for (const attribute of attributes) {
      const attr = element.attributes.getNamedItem(attribute);
      if (attr == null) continue;
      const val = attr.value.toLowerCase();
      if (val.includesAnyRegExp(excludesAll)) {
        return false;
      }
    }
    for (const attribute of attributes) {
      const attr = element.attributes.getNamedItem(attribute);
      if (attr === null) continue;
      const val = attr.value.toLowerCase();
      if (val.includesAnyRegExp(includesAny)) {
        return true;
      }
    }
    if (includesAny.length == 0) return true;
    return false;
  };
}

function isHidden(elem) {
  if (!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length)) return true;
  const style = window.getComputedStyle(elem);
  if (style.display === "none" || style.opacity === 0 || style.visibility === "hidden") return true;
  const pos = getMidPoint(elem);
  const e = document.elementFromPoint(pos.x, pos.y);
  return !isEqualOrChild(e, elem);
}

function isEqualOrChild(child, parent) {
  if (child == parent) return true;
  if (child === null || parent === null) return false;
  while (child.parentElement !== null) {
    child = child.parentElement;
    if (child == parent) return true;
  }
  return false;
}

function verifyRecaptcha() {
  if (!recaptchaConfirmOnce) {
    try {
      if (grecaptcha.getResponse().length !== 0) {
        alert("Recaptcha verified");
        recaptchaConfirmOnce = true;
        console.log("VERIFY RECAP");
        ipcRenderer.sendToHost("recaptchaSuccess");
      }
    } catch (error) {
      console.error("Recaptcha ERROR:", error);
      if (String(error).includes("No reCAPTCHA clients exist")) {
        console.log("No Recaptcha");
        recaptchaConfirmOnce = true;
        ipcRenderer.sendToHost("recaptchaSuccess");
      }
    }
  }
}

function findRecaptcha() {
  let t = document.querySelector('iframe[src*="/recaptcha/"]');
  console.log("button", t);
  if (t == null) {
    return false;
  }
  return t;
}

async function recaptchaClick(recap) {
  console.log("LET CLICK", recap);
  if (!checkRecaptcha) {
    recap.scrollIntoView();
    recap.focus();
    checkRecaptcha = true;
    let pos = recap.getBoundingClientRect();
    ipcRenderer.sendToHost("recaptcha", pos.left, pos.width, pos.top, pos.height);
  }
}

start();

//Script based login functions

async function execute(operations) {
  bot = true;
  let doc;
  for ({ operation, args } of operations) {
    console.log("EXECUTE", operation, args);
    doc = document;
    switch (operation) {
      case "sleep":
        let randomrange = args.randomrange || args.seconds / 5;
        await sleep(Math.max(0, args.seconds + Math.random() * randomrange - randomrange / 2));
        break;
      case "waitfor":
        doc = args.document || document;
        console.log("waitfor", doc.querySelector(args.selector));
        while (!doc.querySelector(args.selector)) {
          await sleep(95 + Math.random() * 10);
        }
        break;
      case "click":
        await execute([{ operation: "waitfor", args }]);
        doc = args.document || document;
        console.log("CLICK", doc.querySelector(args.selector));
        await clickButton(doc.querySelector(args.selector));
        break;
      case "fill":
        doc = args.document || document;
        await fillFormField(doc.querySelector(args.selector), args.fillkey);
        break;
      case "solverecaptcha":
        doc = args.document || document;
        await recaptchaClick(doc.querySelector(args.selector));
        if (!recaptchaConfirmOnce) {
          setInterval(verifyRecaptcha, 100);
        }
        break;
      case "recaptcha":
        await execute([
          { operation: "waitfor", args },
          { operation: "solverecaptcha", args }
        ]);
      case "waitandfill":
        await execute([
          { operation: "waitfor", args },
          { operation: "click", args },
          { operation: "fill", args }
        ]);
        break;
      case "repeatFill": //same as waitandfill but here to retain the information of the repeat
        await execute([
          { operation: "waitfor", args },
          { operation: "click", args },
          { operation: "fill", args }
        ]);
    }
  }
  return;
}

async function fillFormField(target, fillkey) {
  //console.log("FILL", target, content);
  //if (stopped) throw new Error("abort");
  //target.focus();
  // await sleep(250);
  // target.focus();
  //  await sleep(250);
  const p = new Promise(resolve =>
    ipcRenderer.once("formFieldFilled", async (e, key) => {
      //if (stopped) return;
      resolve();
    })
  );
  ipcRenderer.sendToHost("fillFormField", fillkey);
  return p;
}

async function execute(operations, mainexecute = false) {
  bot = true;
  console.log("Hier1", operations);
  let doc;
  if (mainexecute) {
    ipcRenderer.sendToHost("executeStep");
  }
  for ({ operation, args = {} } of operations) {
    console.log("EXECUTE", operation, args);

    doc = args.document ? document.querySelector(args.document).contentWindow.document : document;
    switch (operation) {
      case "sleep":
        let randomrange = args.randomrange || args.seconds / 5;
        await sleep(Math.max(0, args.seconds + Math.random() * randomrange - randomrange / 2));
        break;
      case "waitfor":
        const p = new Promise(async resolve => {
          while (!doc.querySelector(args.selector)) {
            doc = args.document
              ? document.querySelector(args.document).contentWindow.document
              : document;
            await sleep(95 + Math.random() * 10);
          }
          resolve();
        });
        await p;
        break;
      case "click":
        await execute([{ operation: "waitfor", args }]);
        console.log("CLICK", doc.querySelector(args.selector));
        await clickButton(doc.querySelector(args.selector), args.document);
        break;
      case "fill":
        console.log("fill", doc.querySelector(args.selector), args.fillkey);
        await fillFormField(doc.querySelector(args.selector), args.fillkey);
        break;
      case "solverecaptcha":
        console.log("solverecaptcha", doc.querySelector(args.selector));
        await recaptchaClick(doc.querySelector(args.selector));
        if (!recaptchaConfirmOnce) {
          setInterval(verifyRecaptcha, 100);
        }
        break;
      case "recaptcha":
        await execute([
          { operation: "waitfor", args },
          { operation: "solverecaptcha", args }
        ]);
        break;
      case "waitandfill":
        await execute([
          { operation: "waitfor", args },
          { operation: "click", args },
          { operation: "fill", args }
        ]);
        break;
      case "repeatFill":
        await execute([
          { operation: "waitfor", args },
          { operation: "click", args },
          { operation: "fill", args }
        ]);
        break;
      case "cookie":
        let cookiebutton = null;

        let totaltime = 0;
        console.log("EXECUTE COOKIE");
        while (totaltime < 5000) {
          console.log(doc.querySelector(args.selector), cookiebutton);
          if (args.selector ? doc.querySelector(args.selector) : cookiebutton) {
            //Wait for animations
            let oldposx,
              oldposy,
              oldposx2,
              oldposy2 = undefined;
            let newposx,
              newposy,
              newposx2,
              newposy2 = undefined;
            let rect;
            let waittime = 0;
            while (
              (!(
                oldposx == newposx &&
                oldposy == newposy &&
                oldposx2 == newposx2 &&
                oldposy2 == newposy2
              ) ||
                oldposx == undefined) &&
              waittime < 5000
            ) {
              oldposx = newposx;
              oldposy = newposy;
              oldposx2 = newposx2;
              oldposy2 = newposy2;
              rect = doc.querySelector(args.selector).getBoundingClientRect();
              newposx = rect.left;
              newposy = rect.top;
              newposx2 = rect.right;
              newposy2 = rect.bottom;
              await sleep(100);
              waittime += 100;
            }

            await clickButton(args.selector ? doc.querySelector(args.selector) : cookiebutton);
            break;
          }
          await sleep(300);
          totaltime += 300;
          cookiebutton = await findCookieButton();
        }
        break;
    }
  }
  return;
}
