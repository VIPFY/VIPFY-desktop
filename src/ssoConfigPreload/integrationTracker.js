console.log("Testing");
let ipcRenderer = require("electron").ipcRenderer;
var iframeList = [];
let stopped = false;
let cookiefound = false;
let recaptchaConfirmOnce = false;
let checkRecaptcha = false;
let bot = false;
let webview;
//let ticking = false;
var scrollTimer = -1;

var listeners = [];

const asktypes = ["input", "textbox"];

(function () {
  Element.prototype._addEventListener = Element.prototype.addEventListener;
  Element.prototype.addEventListener = function (a, b, c) {
    console.log("Element.prototype.addEventListener");
    if (c == undefined) c = false;
    this._addEventListener(a, b, c);
    if (!this.eventListenerList) this.eventListenerList = {};
    if (!this.eventListenerList[a]) this.eventListenerList[a] = [];
    //this.removeEventListener(a,b,c); // TODO - handle duplicates..
    this.eventListenerList[a].push({ listener: b, useCapture: c });
  };

  Element.prototype.getEventListeners = function (a) {
    console.log("Element.prototype.getEventListener");
    if (!this.eventListenerList) this.eventListenerList = {};
    if (a == undefined) return this.eventListenerList;
    return this.eventListenerList[a];
  };
  /*Element.prototype.clearEventListeners = function (a) {
    console.log("Element.prototype.clearEventListener");
    if (!this.eventListenerList) this.eventListenerList = {};
    if (a == undefined) {
      for (var x in this.getEventListeners()) this.clearEventListeners(x);
      return;
    }
    var el = this.getEventListeners(a);
    if (el == undefined) return;
    for (var i = el.length - 1; i >= 0; --i) {
      var ev = el[i];
      this.removeEventListener(a, ev.listener, ev.useCapture);
    }
  };*/

  Element.prototype._removeEventListener = Element.prototype.removeEventListener;
  Element.prototype.removeEventListener = function (a, b, c) {
    console.log("Element.prototype.removeEventListener");
    if (c == undefined) c = false;
    this._removeEventListener(a, b, c);
    if (!this.eventListenerList) this.eventListenerList = {};
    if (!this.eventListenerList[a]) this.eventListenerList[a] = [];

    // Find the event in the list
    for (var i = 0; i < this.eventListenerList[a].length; i++) {
      if (
        (this.eventListenerList[a][i].listener == b, this.eventListenerList[a][i].useCapture == c)
      ) {
        // Hmm..
        this.eventListenerList[a].splice(i, 1);
        break;
      }
    }
    if (this.eventListenerList[a].length == 0) delete this.eventListenerList[a];
  };
})();

Object.defineProperty(String.prototype, "includesAny", {
  value: function (searches) {
    for (const search of searches) {
      if (this.indexOf(search) !== -1) {
        return true;
      }
    }
    return false;
  }
});

Object.defineProperty(String.prototype, "includesAnyRegExp", {
  value: function (searches) {
    for (const search of searches) {
      if (search.test(this)) {
        return true;
      }
    }
    return false;
  }
});

const skipArgs = ["placeholder", "alt", "title", "aria-label", "class"]; // don't use attributes likely to get translated
function createObjFromDom(elem) {
  if (elem == null) return null;
  //console.log(elem);
  if (elem.nodeType !== 1) {
    // ELEMENT_NODE
    return null;
  }
  const o = { tag: elem.tagName };
  if (elem.hasAttributes) {
    o.attr = {};
    for (const attr of elem.attributes) {
      if (skipArgs.includes(attr.name.toLowerCase())) {
        continue;
      }
      if (attr.name.includesAny([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])) {
        // attributes with numbers are likely to be autogenerated
        continue;
      }
      if (attr.value == "") {
        // empty attributes are often not a good selector choice
        continue;
      }
      o.attr[attr.name] = attr.value;
    }
  }
  o.empty = !elem.hasChildNodes();
  return o;
}

async function onExecute(args1, booler) {
  console.log("ON EXECUTE", args1, booler);
  await execute(args1, booler);
  //reset everything
  listeners = [];
  iframeList = [];
  stopped = false;
  cookiefound = false;
  recaptchaConfirmOnce = false;
  checkRecaptcha = false;
  bot = false;
}

ipcRenderer.on("delockItem", async (e, args1) => {
  const element = document.querySelector(args1);
  if (element == null) {
    return;
  }
  element.disabled = false;
  element.clearEventListeners(); //remove the perventDefault
  const listeners1 =
    listeners[
      listeners.findIndex(elemente => {
        return elemente[0] == element;
      })
    ][1];
  Object.keys(listeners1).forEach(key => {
    listeners1[key].forEach(i => element.addEventListener(key, i));
  });
  listeners.splice(
    //entferne alte Objekte wieder aus der Liste
    listeners.findIndex(elemente => {
      return elemente[0] == element;
    }),
    1
  );
  console.log("Events Regiven");
});

ipcRenderer.on("givePosition", async (e, args1, args2, args3) => {
  const ding = document.querySelector(args1);
  console.log("givePositionBack", ding, args1);
  if (ding == null) {
    return;
  }
  const rect = ding.getBoundingClientRect();
  ipcRenderer.sendToHost(
    "givePosition",
    ding.clientWidth,
    ding.clientHeight,
    rect.x,
    rect.y,
    args2,
    args3
  );
});

function giveIframeEvents(iframe, list, events) {
  console.log("iframe", iframe, list, events);
  if (list) {
    iframeList.push(iframe);
  }
  if (events) {
    console.log("IDocument", iframe.contentWindow.document);
    if (iframe.contentDocument) {
      iframe.contentWindow.document.addEventListener("click", e => findTarget(e, iframe), true);
      iframe.contentWindow.document.addEventListener("keyup", e => findTarget(e, iframe), true);
      iframe.contentWindow.document.addEventListener("input", e => findTarget(e, iframe), true);
      iframe.contentWindow.document.addEventListener("paste", e => findTarget(e, iframe), true);
    }
    console.log("LOAD FIRST", iframe);
    iframe.addEventListener("load", e => {
      console.log("LOAD", e, iframe);
      if (iframe.contentDocument) {
        iframe.contentWindow.document.addEventListener("keyup", e => findTarget(e, iframe), true);
        iframe.contentWindow.document.addEventListener("input", e => findTarget(e, iframe), true);
        iframe.contentWindow.document.addEventListener("click", e => findTarget(e, iframe), true);
        iframe.contentWindow.document.addEventListener("paste", e => findTarget(e, iframe), true);
      }
    });
  }
  var observer = new MutationObserver(callback2);
  observer.observe(iframe, config);
}

function removeIframeEvents(iframe, list, events) {
  console.log("iframe", iframe, list, events);
  if (list) {
    iframeList.push(iframe);
  }
  if (events) {
    console.log("IDocument", iframe.contentWindow.document);
    if (iframe.contentDocument) {
      iframe.contentWindow.document.removeEventListener("click", e => findTarget(e, iframe), true);
      iframe.contentWindow.document.removeEventListener("keyup", e => findTarget(e, iframe), true);
      iframe.contentWindow.document.removeEventListener("input", e => findTarget(e, iframe), true);
      iframe.contentWindow.document.removeEventListener("paste", e => findTarget(e, iframe), true);
    }
    console.log("LOAD FIRST", iframe);
    iframe.removeEventListener("load", e => {
      console.log("LOAD", e, iframe);
      if (iframe.contentDocument) {
        iframe.contentWindow.document.removeEventListener(
          "keyup",
          e => findTarget(e, iframe),
          true
        );
        iframe.contentWindow.document.removeEventListener(
          "input",
          e => findTarget(e, iframe),
          true
        );
        iframe.contentWindow.document.removeEventListener(
          "click",
          e => findTarget(e, iframe),
          true
        );
        iframe.contentWindow.document.removeEventListener(
          "paste",
          e => findTarget(e, iframe),
          true
        );
      }
    });
  }
  var observer = new MutationObserver(callback2);
  observer.observe(iframe, config);
}

function findAllIframes(doc, remove) {
  let iframes = doc.querySelectorAll("iframe");
  iframes.forEach(iframe => {
    if (!isHidden(iframe) && iframe.contentDocument) {
      findAllIframes(iframe.contentWindow.document);
    }
  });
  let machKaputt = [];
  for (let i = 0; i < iframes.length; i++) {
    const iframe = iframes[i];
    if (iframeList.indexOf(iframe) === -1) {
      machKaputt.push(iframes[i]);
    }
  }
  iframes = machKaputt;
  if (remove) {
    iframes.forEach(iframe => removeIframeEvents(iframe, true, true));
  } else {
    iframes.forEach(iframe => giveIframeEvents(iframe, true, true));
  }
}

var config = { attributes: true, childList: true, subtree: true };

var callback1 = function (mutationsList, observer) {
  for (var mutation of mutationsList) {
    if (mutation.type == "childList") {
      mutation.addedNodes.forEach(node => {
        findAllIframes(document);
      });
      mutation.removedNodes.forEach(node => {
        if (node.tagName == "IFRAME") {
          var index = iframeList.indexOf(node);
          if (index > -1) {
            iframeList.splice(index, 1);
          }
        }
      });
    }
  }
};

var callback2 = function (mutationsList, observer) {
  //console.log("Callback2 called");
  for (var mutation of mutationsList) {
    if (mutation.type == "childList") {
      mutation.addedNodes.forEach(node => {
        //console.log("Node added", node.tagName);
        if (node.tagName == "IFRAME") {
          giveIframeEvents(node, false, true);
          findAllIframes(observer.iframe);
        }
      });
      mutation.removedNodes.forEach(node => {
        //console.log("Node removed", node.tagName);
        if (node.tagName == "IFRAME") {
          var index = iframeList.indexOf(node);
          if (index > -1) {
            iframeList.splice(index, 1);
          }
        }
      });
    }
  }
};

window.addEventListener("DOMContentLoaded", () => {
  ipcRenderer.sendToHost("loaded");
});

window.addEventListener("load", () => {
  ipcRenderer.sendToHost("loaded");
});

var observer = new MutationObserver(callback1);
observer.observe(document, config);

const attributesSelector = [
  "name",
  "id",
  "aria-label",
  "aria-roledescription",
  "placeholder",
  "ng-model",
  "data-ng-model",
  "data-callback",
  "data-name",
  "class",
  "alt",
  "data-testid",
  "href",
  "data-event-click-target",
  "data-ng-click",
  "data-track-properties"
];

function findTarget(event, iframe) {
  ipcRenderer.sendToHost("aktualisiereDivList");
  console.log("TESTING", bot);
  if (bot) {
    return;
  }

  console.log("findTarget", event, event.target, iframe);
  //return;
  /* if(event.type == "click") {
        console.log("Event", event)
    } */
  //console.log("Event", event.target)
  const element1 = event.target.cloneNode("true");
  //console.log("CLONE", element1)
  var rect = event.target.getBoundingClientRect();
  const style = window.getComputedStyle(event.target);

  var obj = createObjFromDom(element1);
  if (iframe) {
    console.log(createObjFromDom(iframe));
  }

  //const button = event.target;
  const wereans = onClick(event);
  if (wereans[0]) {
    const button = wereans[1];
    const listenersers = button.getEventListeners();
    //ipcRenderer.sendToHost("sendMessage", button, listeners);
    listeners.push([event.target, listenersers]); //
    //button.clearEventListeners();
    button.addEventListener("click", e => {
      console.log("listener added");
      //e.preventDefault();
      return false;
    });
    console.log("Events Cleared");
  }
  console.log("Parents", els);

  if (wereans[0]) {
    var button = wereans[1];
  } else {
    var button = event.target;
  }

  var els = [];
  var a = button.parentNode;
  while (a) {
    els.unshift(a);
    a = a.parentNode;
  }
  if (iframe) {
    a = iframe;
    while (a) {
      els.unshift(a);
      a = a.parentNode;
    }
  }

  var doc = iframe ? iframe.contentWindow.document : document;
  var iselector;
  var selector = "[id='" + obj.attr.id + "']";
  var t = Array.from(doc.querySelectorAll(selector));

  if (t.length != 1) {
    //Either no id or multiple with same
    selector = element1.tagName;
    console.log(obj.attr);
    for (key of Object.keys(obj.attr)) {
      if (attributesSelector.includes(key)) {
        selector += "[" + key + "='" + obj.attr[key] + "']";
      }
    }
    console.log("Selector", selector);
    t = Array.from(doc.querySelectorAll(selector));

    if (t.length != 1) {
      console.log("Need Parents", els);
      var parent = els.pop();
      var pobj;
      var pt;
      var pselector;
      while (parent) {
        console.log("PARENT", parent, selector);
        pobj = createObjFromDom(parent);
        pt = Array.from(doc.querySelectorAll("#" + pobj.attr.id));
        if (pt.length == 1) {
          selector = "#" + pobj.attr.id + " > " + selector;
          break;
        }
        pselector = parent.tagName;
        for (key of Object.keys(pobj.attr)) {
          if (attributesSelector.includes(key)) {
            pselector += "[" + key + "='" + pobj.attr[key] + "']";
          }
        }
        pt = Array.from(doc.querySelectorAll(pselector));
        selector = pselector + " > " + selector;
        if (pt.length == 1) {
          break;
        }
        parent = els.pop();
      }
    }
  }

  if (iframe) {
    console.log("IFRAME ADD");
    var iobj = createObjFromDom(iframe);
    var ia = iframe;
    var iels = [];
    iselector = "#" + iobj.attr.id;
    while (ia) {
      iels.unshift(ia);
      ia = ia.parentNode;
    }
    var i = Array.from(document.querySelectorAll(iselector));

    if (i.length != 1) {
      //Either no id or multiple with same
      iselector = iframe.tagName;
      console.log(iobj.attr);
      for (key of Object.keys(iobj.attr)) {
        if (attributesSelector.includes(key)) {
          iselector += "[" + key + "='" + iobj.attr[key] + "']";
        }
      }
      console.log("ISelector", iselector);
      i = Array.from(document.querySelectorAll(iselector));

      if (i.length != 1) {
        console.log("Need Parents");
        var iparent = iels.pop();
        var ipobj;
        var ipt;
        var ipselector;
        while (iparent) {
          ipobj = createObjFromDom(iparent);
          ipt = Array.from(document.querySelectorAll("#" + ipobj.attr.id));
          if (ipt.length == 1) {
            iselector = "#" + ipobj.attr.id + " > " + iselector;
            break;
          }
          ipselector = iparent.tagName;
          for (key of Object.keys(ipobj.attr)) {
            if (attributesSelector.includes(key)) {
              ipselector += "[" + key + "='" + ipobj.attr[key] + "']";
            }
          }
          ipt = Array.from(document.querySelectorAll(ipselector));

          if (ipt.length == 1) {
            iselector = ipselector + " > " + iselector;
            break;
          }
          iparent = iels.pop();
        }
      }
    }
  }

  ipcRenderer.sendToHost(
    "sendEvent",
    button.tagName,
    button.type,
    button.value,
    createObjFromDom(element1),
    "ID-Elements " + Array.from(document.querySelectorAll(iselector)).length,
    event.type,
    selector,
    { x: rect.x, y: rect.y },
    iselector
  );
  //event.target.disabled = true;
  console.log("buttons disabled");
}

function elemIsButton(t) {
  if (!t) {
    console.log("Not t");
    return false;
  }
  if (t.tagName == "svg") {
    console.log("CHECK TAGNAME IS SVG");
    return false;
  }
  if (t.tagName == "BUTTON" || t.tagName == "INPUT" || t.tagName == "A" || t.tagName == "LABEL") {
    console.log("has special Tag");
    return true;
  }

  if (
    hasEventHandler(t, "click") ||
    hasEventHandler(t, "mousedown") ||
    hasEventHandler(t, "dragstart") ||
    hasEventHandler(t, "onClick")
  ) {
    console.log("has Eventhandler");
    return true;
  }
  console.log("No Button oder sowas");
  return false;
}

function onClick(e) {
  let t = e.target;
  let isButton = true;
  while (t && !elemIsButton(t) && t.parentElement != null) {
    t = t.parentElement;
  }
  if (!t || t.parentElement == null) {
    t = e.target;
    isButton = false;
  }
  console.log("CHECK TAGNAME", isButton, t);
  return [isButton, t];
}

function hasEventHandler(t, e) {
  console.log("E", t);
  return (
    t["on" + e] ||
    t.getAttribute("on" + e) ||
    (t.getEventListeners(e) && t.getEventListeners(e).length > 0)
  );
}

async function onIpcMessage(e) {
  findTarget(event);
  /* ipcRenderer.sendToHost("sendEvent", event.target.tagName, event.target.type, 
                                        event.target.value, createObjFromDom(element1), document.querySelectorAll("INPUT"), event.type, event.which, 
                                        [event.target.clientHeight, event.target.clientWidth, event.offsetX, event.offsetY]); */
}

function findCookieButton() {
  var t = Array.from(
    document.querySelectorAll(
      "[class~=cc-compliance] > [class~=cc-dismiss], [class~='consent'] > a[class~='call'], [ba-click='{{allow()}}']"
    )
  )
    .filter(e => !isHidden(e))
    .filter(e => !e.disabled);
  if (t.length == 0) {
    var trustArc = document.querySelector("[src*='https://consent-pref.trustarc.com/']");
    if (trustArc) {
      t = Array.from(
        trustArc.contentWindow.document.querySelectorAll("[class~=call], [role='button']")
      );
    }
  }
  if (t.length == 0) {
    t = Array.from(
      document.querySelectorAll(
        "button, input[type='checkbox'], input[type='button'], [role='button'], [class~='btn'], [class~='cc-btn'], [class~='button'], [class~='btn-small']"
      )
    )
      .filter(
        filterDom(
          ["dismiss", "cookie", "consent"],
          ["oauth", "google", "facebook", "linkedin", "forgot", "newsletter"]
        )
      )
      .filter(e => !isHidden(e))
      .filter(e => !e.disabled);
  }
  console.log("Cookies", t);
  return t[0];
}

/* function findRecaptcha() {
  let t = document.querySelector('iframe[src*="/recaptcha/"]');
  console.log("button", t);
  if (t == null) {
    return false;
  }
  return t;
} */

window.addEventListener("beforeunload", () => {
  stopped = true;
  console.log("UNLOAD");
  ipcRenderer.sendToHost("unload", null);
});

window.addEventListener("load", async () => {
  //console.log("LOADED", stopped);
  ipcRenderer.sendToHost("loaded", null);
  stopped = false;
  while (!stopped) {
    //console.log("TEST", stopped);
    if (
      document.querySelectorAll(".upgrade-btn")[0] &&
      (!document.querySelectorAll(".upgrade-btn")[0].eventListenerList ||
        (document.querySelectorAll(".upgrade-btn")[0].eventListenerList &&
          !document
            .querySelectorAll(".upgrade-btn")[0]
            .eventListenerList.click.find(e => e.listener.name == "clickAlert")))
    ) {
      document.querySelectorAll(".upgrade-btn")[0].addEventListener("click", clickAlert);
    }
    if (document.querySelector(".store-profile-footer")) {
      var elem = document.querySelector(".store-profile-footer");
      elem.parentNode.removeChild(elem);
    }
    await sleep(300);
  }
});

ipcRenderer.once("startTracking", () => {
  window.addEventListener("scroll", function (e) {
    ipcRenderer.sendToHost("startScroll", window.scrollY);
  });
});

ipcRenderer.on("startTracking", ({ useable }) => {
  console.log("START TRACKING");
  //remove Listeners first in case they already exist (no doubles);
  document.removeEventListener("click", findTarget, true);
  document.removeEventListener("keyup", findTarget, true);
  document.removeEventListener("input", findTarget, true);
  document.removeEventListener("paste", findTarget, true);
  document.addEventListener("click", findTarget, true);
  document.addEventListener("keyup", findTarget, true);
  document.addEventListener("input", findTarget, true);
  document.addEventListener("paste", findTarget, true);
  ipcRenderer.sendToHost("trackingStarted");

  findAllIframes(document, false);
});

ipcRenderer.on("removeTracking", () => {
  document.removeEventListener("click", findTarget, true);
  document.removeEventListener("keyup", findTarget, true);
  document.removeEventListener("input", findTarget, true);
  document.removeEventListener("paste", findTarget, true);
  ipcRenderer.sendToHost("trackingEnded");

  findAllIframes(document, true);
});

ipcRenderer.on("hide element", async (e, args1, args2, args3) => {
  let ding = document.querySelector(args1);
  for (let i = 0; i < args3; i++) {
    if (ding.displaySave) {
      ipcRenderer.sendToHost("true PPP");
    } else {
      ipcRenderer.sendToHost("false PPP");
    }
    ipcRenderer.sendToHost(
      "Hide Element triggered",
      ding.style.display,
      ding.displaySave,
      args2,
      1
    );
    if (args2) {
      //Hide Element
      if (!(ding.style.display == "none")) {
        ding.displaySave = ding.style.display;
        ding.style.display = "none";
      }
    } else {
      //Show Element
      if (
        ding.style.display == "none" &&
        ding.displaySave !== undefined &&
        ding.displaySave != null
      ) {
        ding.style.display = ding.displaySave;
        ding.displaySave = null;
      }
    }
    ding = ding.parentElement;
  }
  //Show the parentElement if is was hiden from me and is not anymore in the list
  if (ding.style.display == "none" && ding.displaySave !== undefined && ding.displaySave != null) {
    ding.style.display = ding.displaySave;
    ding.displaySave = null;
  }

  ipcRenderer.sendToHost("Hide Element triggered", ding.style.display, ding.displaySave, args2, 2);
});

ipcRenderer.on("getSelectOptions", async (e, args1) => {
  const options = [];
  if (document.querySelector(args1).options) {
    Array.prototype.forEach.call(document.querySelector(args1).options, o => {
      if (o.innerText && o.value) {
        options.push({ label: o.innerText, value: o.value });
      }
    });
  }
  ipcRenderer.sendToHost("selectOptions", options);
});

function clickAlert() {
  ipcRenderer.sendToHost("clickAlert");
}

async function start() {
  ipcRenderer.sendToHost("hello");
}

ipcRenderer.on("execute", async (e, args1) => {
  console.log("RECEIVE EXECUTE", args1);
  onExecute(args1, true);
});

function clickButton(targetNode) {
  var rect = getMidPoint(targetNode, 0.5, 0.5);

  //if (stopped) throw new Error("abort");
  const p = new Promise(resolve =>
    ipcRenderer.once("clicked", async (e, key) => {
      //if (stopped) return;
      resolve();
    })
  );
  ipcRenderer.sendToHost("click", rect.x, rect.y);
  return p;
}

function getMidPoint(e, px = 0.2, py = 0.5) {
  var rect = e.getBoundingClientRect();
  const style = window.getComputedStyle(e);
  return {
    x:
      rect.x +
      parseInt(style.paddingLeft) +
      (rect.width - parseInt(style.paddingLeft) - parseInt(style.paddingRight)) * px,
    y:
      rect.y +
      parseInt(style.paddingTop) +
      (rect.height - parseInt(style.paddingTop) - parseInt(style.paddingBottom)) * py
  }; // bias to the left
}

const sleep = async ms => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

const attributes = [
  "name",
  "id",
  "aria-label",
  "aria-roledescription",
  "placeholder",
  "ng-model",
  "data-ng-model",
  "data-callback",
  "data-name",
  "class",
  "value",
  "alt",
  "data-testid",
  "href",
  "data-event-click-target",
  "data-ng-click",
  "data-track-properties"
];

function filterDom(includesAny, excludesAll) {
  includesAny = includesAny.map(i => new RegExp(i));
  excludesAll = excludesAll.map(i => new RegExp(i));
  return function (element) {
    if (!element.hasAttributes()) {
      return false;
    }
    if (element.scrollHeight == 0 || element.scrollWidth == 0) {
      return false; //don't select elements that aren't visible
    }
    for (const attribute of attributes) {
      const attr = element.attributes.getNamedItem(attribute);
      if (attr == null) continue;
      const val = attr.value.toLowerCase();
      if (val.includesAnyRegExp(excludesAll)) {
        return false;
      }
    }
    for (const attribute of attributes) {
      const attr = element.attributes.getNamedItem(attribute);
      if (attr === null) continue;
      const val = attr.value.toLowerCase();
      if (val.includesAnyRegExp(includesAny)) {
        return true;
      }
    }
    if (includesAny.length == 0) return true;
    return false;
  };
}

function isHidden(elem) {
  if (!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length)) return true;
  const style = window.getComputedStyle(elem);
  if (style.display === "none" || style.opacity === 0 || style.visibility === "hidden") return true;
  const pos = getMidPoint(elem);
  const e = document.elementFromPoint(pos.x, pos.y);
  return !isEqualOrChild(e, elem);
}

function isEqualOrChild(child, parent) {
  if (child == parent) return true;
  if (child === null || parent === null) return false;
  while (child.parentElement !== null) {
    child = child.parentElement;
    if (child == parent) return true;
  }
  return false;
}

function verifyRecaptcha() {
  if (!recaptchaConfirmOnce) {
    try {
      if (grecaptcha.getResponse().length !== 0) {
        alert("Recaptcha verified");
        recaptchaConfirmOnce = true;
        console.log("VERIFY RECAP");
        ipcRenderer.sendToHost("recaptchaSuccess");
      }
    } catch (error) {
      console.error("Recaptcha ERROR:", error);
      if (String(error).includes("No reCAPTCHA clients exist")) {
        console.log("No Recaptcha");
        recaptchaConfirmOnce = true;
        ipcRenderer.sendToHost("recaptchaSuccess");
      }
    }
  }
}

function findRecaptcha() {
  let t = document.querySelector('iframe[src*="/recaptcha/"]');
  console.log("button", t);
  if (t == null) {
    return false;
  }
  return t;
}

async function recaptchaClick(recap) {
  console.log("LET CLICK", recap);
  if (!checkRecaptcha) {
    recap.scrollIntoView();
    recap.focus();
    checkRecaptcha = true;
    let pos = recap.getBoundingClientRect();
    ipcRenderer.sendToHost("recaptcha", pos.left, pos.width, pos.top, pos.height);
  }
}

start();

async function fillFormField(target, fillkey) {
  const p = new Promise(resolve =>
    ipcRenderer.once("formFieldFilled", async (e, key) => {
      //if (stopped) return;
      resolve();
    })
  );
  ipcRenderer.sendToHost("fillFormField", fillkey);
  return p;
}

async function backSpace(target, length) {
  const p = new Promise(resolve =>
    ipcRenderer.once("backSpaced", async (e, key) => {
      resolve();
    })
  );
  ipcRenderer.sendToHost("backSpace", length);
  return p;
}

async function execute(executeoperations, mainexecute = false) {
  bot = true;
  console.log("Hier1", executeoperations, mainexecute);
  await sleep(500);
  let doc;
  for ({ operation, args = {} } of executeoperations) {
    if (stopped) {
      break;
    }
    if (mainexecute) {
      console.log("executeStep", executeoperations.length);
      await ipcRenderer.sendToHost("executeStep");
    }
    console.log("EXECUTE", operation, args);

    doc = args.document ? document.querySelector(args.document).contentWindow.document : document;
    switch (operation) {
      case "sleep":
        let randomrange = args.randomrange || args.seconds / 5;
        await sleep(Math.max(0, args.seconds + Math.random() * randomrange - randomrange / 2));
        break;
      case "waitfor":
        const p = new Promise(async resolve => {
          while (!doc.querySelector(args.selector)) {
            doc = args.document
              ? document.querySelector(args.document).contentWindow.document
              : document;
            await sleep(95 + Math.random() * 10);
          }
          resolve();
        });
        await p;
        break;
      case "click":
        await execute([{ operation: "waitfor", args }]);
        console.log("CLICK", doc.querySelector(args.selector));
        await clickButton(doc.querySelector(args.selector), args.document);
        break;
      case "clean":
        if (doc.querySelector(args.selector).value) {
          await backSpace(
            doc.querySelector(args.selector),
            doc.querySelector(args.selector).value.length
          );
        }
        break;
      case "fill":
        console.log("fill", doc.querySelector(args.selector), args.fillkey);
        await fillFormField(doc.querySelector(args.selector), args.fillkey);
        break;
      case "solverecaptcha":
        console.log("solverecaptcha", doc.querySelector(args.selector));
        await recaptchaClick(doc.querySelector(args.selector));
        if (!recaptchaConfirmOnce) {
          setInterval(verifyRecaptcha, 100);
        }
        break;
      case "recaptcha":
        await execute([
          { operation: "waitfor", args },
          { operation: "solverecaptcha", args }
        ]);
        break;
      case "waitandfill":
        await execute([
          { operation: "waitfor", args },
          { operation: "click", args },
          { operation: "fill", args }
        ]);
        break;
      case "waitandcleanandfill":
        await execute([
          { operation: "waitfor", args },
          { operation: "click", args },
          { operation: "clean", args },
          { operation: "fill", args }
        ]);
        break;
      case "repeatFill":
        await execute([
          { operation: "waitfor", args },
          { operation: "click", args },
          { operation: "fill", args }
        ]);
        break;
      case "cookie":
        let cookiebutton = null;

        let totaltime = 0;
        console.log("EXECUTE COOKIE");
        while (totaltime < 5000) {
          console.log(doc.querySelector(args.selector), cookiebutton);
          if (args.selector ? doc.querySelector(args.selector) : cookiebutton) {
            //Wait for animations
            let oldposx,
              oldposy,
              oldposx2,
              oldposy2 = undefined;
            let newposx,
              newposy,
              newposx2,
              newposy2 = undefined;
            let rect;
            let waittime = 0;
            while (
              (!(
                oldposx == newposx &&
                oldposy == newposy &&
                oldposx2 == newposx2 &&
                oldposy2 == newposy2
              ) ||
                oldposx == undefined) &&
              waittime < 5000
            ) {
              oldposx = newposx;
              oldposy = newposy;
              oldposx2 = newposx2;
              oldposy2 = newposy2;
              rect = doc.querySelector(args.selector).getBoundingClientRect();
              newposx = rect.left;
              newposy = rect.top;
              newposx2 = rect.right;
              newposy2 = rect.bottom;
              await sleep(100);
              waittime += 100;
            }

            await clickButton(args.selector ? doc.querySelector(args.selector) : cookiebutton);
            break;
          }
          await sleep(300);
          totaltime += 300;
          cookiebutton = await findCookieButton();
        }
        break;
    }
  }
  if (mainexecute) {
    ipcRenderer.sendToHost("endExecution", null);
  }
  return;
}
