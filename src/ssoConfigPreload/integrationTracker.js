console.log("Testing");
let ipcRenderer = require("electron").ipcRenderer;
var iframeList = [];
let stopped = false;
let cookiefound = false;

Object.defineProperty(String.prototype, "includesAny", {
  value: function(searches) {
    for (const search of searches) {
      if (this.indexOf(search) !== -1) {
        return true;
      }
    }
    return false;
  }
});

Object.defineProperty(String.prototype, "includesAnyRegExp", {
  value: function(searches) {
    for (const search of searches) {
      if (search.test(this)) {
        return true;
      }
    }
    return false;
  }
});

const skipArgs = ["placeholder", "alt", "title", "aria-label"]; // don't use attributes likely to get translated
const hash = require("object-hash");
function createObjFromDom(elem) {
  if (elem == null) return null;
  //console.log(elem);
  if (elem.nodeType !== 1) {
    // ELEMENT_NODE
    return null;
  }
  const o = { tag: elem.tagName };
  if (elem.hasAttributes) {
    o.attr = {};
    for (const attr of elem.attributes) {
      if (skipArgs.includes(attr.name.toLowerCase())) {
        continue;
      }
      if (attr.name.includesAny([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])) {
        // attributes with numbers are likely to be autogenerated
        continue;
      }
      if (attr.value == "") {
        // empty attributes are often not a good selector choice
        continue;
      }
      o.attr[attr.name] = attr.value;
    }
  }
  o.empty = !elem.hasChildNodes();
  o.hash = hash(o);
  return o;
}

function giveIframeEvents(iframe, list, events) {
  //console.log("iframe", iframe)
  if (list) {
    iframeList.push(iframe);
  }
  if (events) {
    iframe.contentWindow.document.addEventListener("click", findTarget, true);
    iframe.contentWindow.document.addEventListener("keyup", findTarget, true);
    iframe.contentWindow.document.addEventListener("input", findTarget, true);
    iframe.contentWindow.document.addEventListener("paste", findTarget, true);
    //console.log("LOAD FIRST", iframe)
    iframe.contentWindow.addEventListener("load", e => {
      //console.log("LOAD", e)
      e.target.addEventListener("keyup", findTarget, true);
      e.target.addEventListener("input", findTarget, true);
      e.target.addEventListener("click", findTarget, true);
      e.target.addEventListener("paste", findTarget, true);
    });
  }
  var observer = new MutationObserver(callback2);
  observer.observe(iframe, config);
  //iframe.contentWindow.document.addEventListener("DOMSubtreeModified", (e) => {
  /* if (e.target.tagName=="IFRAME"){
        console.log("IFRAME ALL", e);
        e.target.contentWindow.document.addEventListener("keyup", findTarget,true);
        e.target.contentWindow.document.addEventListener("input", findTarget,true);
        e.target.contentWindow.document.addEventListener("click", findTarget,true);
        e.target.contentWindow.document.addEventListener("paste", findTarget,true);
        findAllIframes(e.target.contentWindow.document);
    }
    */
}

function findAllIframes(doc) {
  //console.log("findAllIframes called");
  let iframes = doc.querySelectorAll("iframe");
  iframes.forEach(iframe => findAllIframes(iframe.contentWindow.document));
  let machKaputt = [];
  for (let i = 0; i < iframes.length; i++) {
    const iframe = iframes[i];
    if (iframeList.indexOf(iframe) === -1) {
      machKaputt.push(iframes[i]);
    }
  }
  iframes = machKaputt;
  //console.log("New iframes", iframes)
  iframes.forEach(iframe => giveIframeEvents(iframe, true, true));
}

let webview;
//console.log(webview[0]);

var config = { attributes: true, childList: true, subtree: true };

var callback1 = function(mutationsList, observer) {
  //console.log(iframeList);
  //var newChilds = [];
  for (var mutation of mutationsList) {
    if (mutation.type == "childList") {
      mutation.addedNodes.forEach(node => {
        //console.log("Node added", node.tagName);
        //if(node.tagName == "IFRAME") {
        //giveIframeEvents(node);
        findAllIframes(document);
        //}
        //newChilds.push(node);
      });
      mutation.removedNodes.forEach(node => {
        //console.log("Node removed", node.tagName);
        if (node.tagName == "IFRAME") {
          var index = iframeList.indexOf(node);
          if (index > -1) {
            iframeList.splice(index, 1);
          }
        }
      });
      /*             console.log('A child node has been added or removed.');
       */
    }
    /* else if (mutation.type == 'attributes') {
            console.log('The ' + mutation.attributeName + ' attribute was modified.');
        } */
  }
  //return newChilds;
};

var callback2 = function(mutationsList, observer) {
  //console.log("Callback2 called");
  for (var mutation of mutationsList) {
    if (mutation.type == "childList") {
      mutation.addedNodes.forEach(node => {
        //console.log("Node added", node.tagName);
        if (node.tagName == "IFRAME") {
          giveIframeEvents(node, false, true);
          findAllIframes(observer.iframe);
        }
      });
      mutation.removedNodes.forEach(node => {
        //console.log("Node removed", node.tagName);
        if (node.tagName == "IFRAME") {
          var index = iframeList.indexOf(node);
          if (index > -1) {
            iframeList.splice(index, 1);
          }
        }
      });
    }
  }
};

//webview.addEventListener("loadend", () => {console.log("Yeaaa")});
/* window.addEventListener("DOMSubtreeModified", (e) => {
    if (e.target.tagName=="IFRAME"){
        console.log("IFRAME", e);
        e.target.contentWindow.document.addEventListener("keyup", findTarget,true);
        e.target.contentWindow.document.addEventListener("input", findTarget,true);
        e.target.contentWindow.document.addEventListener("click", findTarget,true);
        e.target.contentWindow.document.addEventListener("paste", findTarget,true);
        findAllIframes(e.target.contentWindow.document);

        e.target.contentWindow.addEventListener("load", () => {
            e.target.contentWindow.document.addEventListener("keyup", findTarget,true);
            e.target.contentWindow.document.addEventListener("input", findTarget,true);
            e.target.contentWindow.document.addEventListener("click", findTarget,true);
            e.target.contentWindow.document.addEventListener("paste", findTarget,true);
            findAllIframes(e.target.contentWindow.document);
        });
    }
    else if (e.target.id) {
        console.log("EVENT", e)
    }
}) */
window.addEventListener("load", () => {
  //webview = document.getElementById("LoginFinder");
  document.addEventListener("click", findTarget, true);
  document.addEventListener("keyup", findTarget, true);
  document.addEventListener("input", findTarget, true);
  document.addEventListener("paste", findTarget, true);
  findAllIframes(document);
});
//document.addEventListener("click", findTarget);
var observer = new MutationObserver(callback1);
observer.observe(document, config);

function findTarget(event) {
  /* if(event.type == "click") {
        console.log("Event", event)
    } */
  //console.log("Event", event.target)
  const element1 = event.target.cloneNode("true");
  //console.log("CLONE", element1)
  var rect = event.target.getBoundingClientRect();
  const style = window.getComputedStyle(event.target);
  console.log("RECT/STYLE", rect, style);
  ipcRenderer.sendToHost(
    "sendEvent",
    event.target.tagName,
    event.target.type,
    event.target.value,
    createObjFromDom(element1),
    document.querySelectorAll("INPUT"),
    event.type,
    event.which,
    { x: rect.x, y: rect.y }
  );
  ipcRenderer.sendToHost(
    "sendClick",
    [event.target.clientWidth, event.target.clientHeight, event.offsetX, event.offsetY],
    [
      [event.screenX - event.offsetX, event.screenY - event.offsetY],
      event.target.clientWidth,
      event.target.clientHeight,
      event.target.clientLeft,
      event.target.clientTop
    ]
  ); //clientLeft clientTop
}

async function onIpcMessage(e) {
  findTarget(event);
  /* ipcRenderer.sendToHost("sendEvent", event.target.tagName, event.target.type, 
                                        event.target.value, createObjFromDom(element1), document.querySelectorAll("INPUT"), event.type, event.which, 
                                        [event.target.clientHeight, event.target.clientWidth, event.offsetX, event.offsetY]); */
}

function findCookieButton() {
  var t = Array.from(
    document.querySelectorAll(
      "[class~=cc-compliance] > [class~=cc-dismiss], [class~='consent'] > a[class~='call']"
    )
  )
    .filter(e => !isHidden(e))
    .filter(e => !e.disabled);
  if (t.length == 0) {
    var trustArc = document.querySelector("[src*='https://consent-pref.trustarc.com/']");
    if (trustArc) {
      t = Array.from(
        trustArc.contentWindow.document.querySelectorAll("[class~=call], [role='button']")
      );
    }
  }
  if (t.length == 0) {
    t = Array.from(
      document.querySelectorAll(
        "button, input[type='button'], [role='button'], [class~='btn'], [class~='cc-btn'], [class~='button'], [class~='btn-small']"
      )
    )
      .filter(
        filterDom(
          ["dismiss", "cookie", "consent"],
          ["oauth", "google", "facebook", "linkedin", "forgot", "newsletter"]
        )
      )
      .filter(e => !isHidden(e))
      .filter(e => !e.disabled);
  }
  console.log("Cookies", t);
  return t[0];
}

async function start() {
  console.log("TEST");
  await sleep(300);
  totaltime = 0;
  while (!stopped) {
    if (!cookiefound) {
      let cookiebutton = findCookieButton();
      console.log("FIND", cookiebutton);
      if (cookiebutton) {
        await sleep(300);
        await clickButton(cookiebutton);
        ipcRenderer.sendToHost("reset");
        await new Promise(resolve =>
          ipcRenderer.once("done", async (e, key) => {
            if (stopped) return;
            resolve();
          })
        );
        cookiefound = true;
      }
    }
    console.log("TEST2");
    await sleep(100);
    totaltime += 100;
  }
}

function clickButton(targetNode) {
  var rect = getMidPoint(targetNode, 0.5, 0.5);

  if (stopped) throw new Error("abort");
  const p = new Promise(resolve =>
    ipcRenderer.once("clicked", async (e, key) => {
      if (stopped) return;
      resolve();
    })
  );
  ipcRenderer.sendToHost("click", rect.x, rect.y);
  return p;
}

function getMidPoint(e, px = 0.2, py = 0.5) {
  var rect = e.getBoundingClientRect();
  const style = window.getComputedStyle(e);
  console.log("STYLES", rect, style);
  return {
    x:
      rect.x +
      parseInt(style.paddingLeft) +
      (rect.width - parseInt(style.paddingLeft) - parseInt(style.paddingRight)) * px,
    y:
      rect.y +
      parseInt(style.paddingTop) +
      (rect.height - parseInt(style.paddingTop) - parseInt(style.paddingBottom)) * py
  }; // bias to the left
}

const sleep = async ms => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

const attributes = [
  "name",
  "id",
  "aria-label",
  "aria-roledescription",
  "placeholder",
  "ng-model",
  "data-ng-model",
  "data-callback",
  "data-name",
  "class",
  "value",
  "alt",
  "data-testid",
  "href",
  "data-event-click-target",
  "data-ng-click"
];

function filterDom(includesAny, excludesAll) {
  includesAny = includesAny.map(i => new RegExp(i));
  excludesAll = excludesAll.map(i => new RegExp(i));
  return function(element) {
    if (!element.hasAttributes()) {
      return false;
    }
    if (element.scrollHeight == 0 || element.scrollWidth == 0) {
      return false; //don't select elements that aren't visible
    }
    for (const attribute of attributes) {
      const attr = element.attributes.getNamedItem(attribute);
      if (attr == null) continue;
      const val = attr.value.toLowerCase();
      if (val.includesAnyRegExp(excludesAll)) {
        return false;
      }
    }
    for (const attribute of attributes) {
      const attr = element.attributes.getNamedItem(attribute);
      if (attr === null) continue;
      const val = attr.value.toLowerCase();
      if (val.includesAnyRegExp(includesAny)) {
        return true;
      }
    }
    if (includesAny.length == 0) return true;
    return false;
  };
}

function isHidden(elem) {
  if (!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length)) return true;
  const style = window.getComputedStyle(elem);
  if (style.display === "none" || style.opacity === 0 || style.visibility === "hidden") return true;
  const pos = getMidPoint(elem);
  const e = document.elementFromPoint(pos.x, pos.y);
  return !isEqualOrChild(e, elem);
}

function isEqualOrChild(child, parent) {
  if (child == parent) return true;
  if (child === null || parent === null) return false;
  while (child.parentElement !== null) {
    child = child.parentElement;
    if (child == parent) return true;
  }
  return false;
}

start();
