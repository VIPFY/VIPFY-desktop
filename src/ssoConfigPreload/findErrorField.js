import { ipcRenderer } from "electron";
import { hash } from "object-hash";

Object.defineProperty(String.prototype, "includesAny", {
  value: function(searches) {
    for (const search of searches) {
      if (this.indexOf(search) !== -1) {
        return true;
      }
    }
    return false;
  }
});

const sleep = async ms => {
  return new Promise(resolve => setTimeout(resolve, ms));
};
async function fillFormField(target, content) {
  target.focus();
  const p = new Promise(resolve =>
    ipcRenderer.once("formFieldFilled", async (e, key) => {
      resolve();
    })
  );
  ipcRenderer.sendToHost("fillFormField", content);
  return p;

  /*target.dispatchEvent(new Event("focus", { bubbles: false, cancelable: false, composed: true }));

  await sleep(142);
  target.dispatchEvent(
    new KeyboardEvent("keyup", {
      bubbles: true,
      cancelable: true,
      composed: true,
      code: "Tab",
      key: "Tab",
      keyCode: 9,
      which: 9
    })
  );

  await sleep(289);
  target.dispatchEvent(
    new KeyboardEvent("keydown", {
      bubbles: true,
      cancelable: true,
      composed: true,
      code: "ControlLeft",
      key: "Control",
      keyCode: 17,
      which: 17
    })
  );
  target.dispatchEvent(
    new KeyboardEvent("keydown", {
      bubbles: true,
      cancelable: true,
      composed: true,
      code: "KeyV",
      ctrlKey: true,
      key: "v",
      keyCode: 86,
      which: 86
    })
  );
  await sleep(5);
  target.value = content;
  target.dispatchEvent(
    new Event("textInput", { bubbles: true, cancelable: true, composed: true, data: content })
  );
  await sleep(5);
  target.dispatchEvent(
    new Event("input", {
      bubbles: true,
      cancelable: true,
      inputType: "insertFromPaste",
      data: null,
      composed: true
    })
  );
  await sleep(256);
  target.dispatchEvent(
    new KeyboardEvent("keyup", {
      bubbles: true,
      cancelable: true,
      composed: true,
      code: "KeyV",
      ctrlKey: true,
      key: "v",
      keyCode: 86,
      which: 86
    })
  );
  await sleep(24);
  target.dispatchEvent(
    new KeyboardEvent("keyup", {
      bubbles: true,
      cancelable: true,
      composed: true,
      code: "ControlLeft",
      key: "Control",
      keyCode: 17,
      which: 17
    })
  );

  await sleep(487);

  target.dispatchEvent(new Event("change", { bubbles: true, cancelable: false }));
  target.dispatchEvent(new Event("blur", { bubbles: false, composed: true, cancelable: false }));*/
}

function clickButton(targetNode) {
  triggerMouseEvent(targetNode, "mouseover");
  setTimeout(() => {
    triggerMouseEvent(targetNode, "mousedown");
    setTimeout(() => {
      triggerMouseEvent(targetNode, "mouseup");
      triggerMouseEvent(targetNode, "click");
    }, 77);
  }, 146);
}

function triggerMouseEvent(node, eventType) {
  node.focus();
  const clickEvent = document.createEvent("MouseEvents");
  clickEvent.initEvent(eventType, true, true);
  node.dispatchEvent(clickEvent);
}

ipcRenderer.sendToHost("loaded", null);

function walkDOM(node, func) {
  if (node == null) return;
  func(node);
  node = node.firstChild;
  while (node) {
    walkDOM(node, func);
    node = node.nextSibling;
  }
}

function sendDomMap(tag) {
  const objects = {};
  walkDOM(document.body, function(n1) {
    const o = createObjFromDom(n1);
    if (o === null) return;
    objects[o.hash] = o;
  });
  ipcRenderer.sendToHost("domMap", tag, objects);
}

setTimeout(function() {
  sendDomMap("before");
  ipcRenderer.sendToHost("ready");
}, 5000);

ipcRenderer.on("loginData", async (e, key) => {
  await sleep(1000);
  await fillFormField(document.querySelector(key.usernameField), key.username);
  sendDomMap(key.tagBefore);
  if (key.button1) {
    clickButton(document.querySelector(key.button1));
    sendDomMap(key.tagBefore);
  }

  await sleep(1564);
  await fillFormField(document.querySelector(key.passwordField), key.password);
  sendDomMap(key.tagBefore);
  clickButton(document.querySelector(key.button || key.button2));

  setTimeout(function() {
    sendDomMap(key.tagAfter);
  }, 8000);
});

const skipArgs = ["placeholder", "alt", "title", "aria-label"]; // don't use attributes likely to get translated
function createObjFromDom(elem) {
  if (elem == null) return null;
  if (elem.nodeType !== 1) {
    // ELEMENT_NODE
    return null;
  }
  const o = { tag: elem.tagName };
  if (elem.hasAttributes) {
    o.attr = {};
    for (const attr of elem.attributes) {
      if (skipArgs.includes(attr.name.toLowerCase())) {
        continue;
      }
      if (attr.name.includesAny([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])) {
        // attributes with numbers are likely to be autogenerated
        continue;
      }
      if (attr.value == "") {
        // empty attributes are often not a good selector choice
        continue;
      }
      o.attr[attr.name] = attr.value;
    }
  }
  o.empty = !elem.hasChildNodes();
  o.hash = hash(o);
  return o;
}
